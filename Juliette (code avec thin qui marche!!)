//determine la couleur du voisin (methode utilise par la suite dans getNeighbours
	public static boolean color(boolean[][] image, int row, int col) {
		boolean couleur = true;
		if( (row >= image.length || row < 0) || (col >= image[0].length || col < 0 ) ) {
			couleur = false;
		} else {
			couleur = image[row][col];
		}
		return couleur;
	}


	public static boolean[] getNeighbours(boolean[][] image, int row, int col) {
		assert (image != null);
		if ((row < 0 || row >= image.length) || (col < 0 || col>= image[0].length)) {
			System.out.println("Pixel donne n'est pas dans l'image");
			return null;
		}

		boolean[] neighbours = new boolean[8];
		neighbours[0] = color(image, row-1, col);
		for(int i = -1; i < 2; ++i) {
			neighbours[i+2] = color(image, row+i, col+1);
		}
		neighbours[4] = color(image, row+1, col);
		neighbours[5] = color(image, row+1, col-1);
		neighbours[6] = color(image, row, col-1);
		neighbours[7] = color(image, row-1, col-1);

		return neighbours;



		// special case that is not expected (the image is supposed to have been checked
		// earlier)
		//TODO implement
	}

	/**
	 * Computes the number of black (<code>true</code>) pixels among the neighbours
	 * of a pixel.
	 *
	 * @param neighbours array containing each pixel value. The array must respect
	 *                   the convention described in
	 *                   {@link #getNeighbours(boolean[][], int, int)}.
	 * @return the number of black neighbours.
	 */

	public static int blackNeighbours(boolean[] neighbours) {

		assert (neighbours != null);

		int black = 0;

		for (int i = 0; i < neighbours.length; ++i) {
			if (neighbours[i] == true) {
				++black;
			}
		}

		return black;

	}



	/**

	 * Computes the number of white to black transitions among the neighbours of

	 * pixel.

	 *

	 * @param neighbours array containing each pixel value. The array must respect

	 *                   the convention described in

	 *                   {@link #getNeighbours(boolean[][], int, int)}.

	 * @return the number of white to black transitions.

	 */

	public static int transitions(boolean[] neighbours) {

		assert (neighbours != null);

		int numberOfTransitions = 0;

		for (int i = 0; i < neighbours.length; ++i) {
			int j = i + 1;

			if (i == 7) {
				j = 0;
			}

			if (neighbours[i] == false && neighbours[j] == true) {
				++ numberOfTransitions;

			}

		}
		return numberOfTransitions;

	}



	/**

	 * Returns <code>true</code> if the images are identical and false otherwise.

	 *

	 * @param image1 array containing each pixel's boolean value.
	 * @param image2 array containing each pixel's boolean value.

	 * @return <code>True</code> if they are identical, <code>false</code>

	 *         otherwise.

	 */

	public static boolean identical(boolean[][] image1, boolean[][] image2) {

		assert ((image1 != null) && (image2 != null));

		//checks if two tableaux are identical
		if ((image1.length != image2.length) || (image1[0].length != image2[0].length) )
			return false;

		for (int i = 0; i < image1.length; ++i) {
			for (int j = 0; j < image1[i].length; ++j) {

				if ((image1[i][j]) != (image2[i][j])) {
					return false;
				}
			}
		}
		return true;
	}

	/**

	 * Internal method used by {@link #thin(boolean[][])}.
	 *
	 * @param image array containing each pixel's boolean value.
	 * @param step  the step to apply, Step 0 or Step 1.

	 * @return A new array containing each pixel's value after the step.

	 */

	public static boolean[][] thinningStep(boolean[][] imageTest, int step) {

		assert ((step == 1 || step == 2) && (imageTest != null));

		boolean[][] imageTest4 = new boolean[imageTest.length][imageTest[0].length];

		for (int i = 0; i < imageTest.length; ++i) {
			for (int j = 0; j < imageTest[i].length; ++j) {
				imageTest4[i][j] = imageTest[i][j];
			}
		}

// boucle for pour déterminer si chaque pixel remplit les conditions

		for (int i = 0; i < imageTest.length; ++i) {
			for (int j = 0; j < imageTest[i].length; ++j) {

				// tests communs aux step 1 et 2

				boolean pixelNoir = imageTest[i][j];
				boolean[] neighbours = getNeighbours(imageTest, i, j);


				if (pixelNoir) {
					System.out.println("case " + i + ", " + j);
					System.out.println("blackN : " + blackNeighbours(neighbours));
					System.out.println("nb transitions : " + transitions(getNeighbours(imageTest, i, j))); }


				if ((pixelNoir) && (neighbours != null) &&
						(blackNeighbours(neighbours)) >= 2 && (blackNeighbours(neighbours) <= 6) &&
						(transitions(neighbours) == 1)) {

					// test step 1

					if (step == 0) {

						if (((getNeighbours(imageTest, i, j)[0] == false) ||(getNeighbours(imageTest, i, j)[2] == false) || (getNeighbours(imageTest, i, j)[4] == false)) &&
								((getNeighbours(imageTest, i, j)[2] == false) ||(getNeighbours(imageTest, i, j)[4] == false) || (getNeighbours(imageTest, i, j)[6] == false))) {
							imageTest4[i][j] = false;
							System.out.println("deleted !");
						}


						// test step 2

					} else if (step == 1) {


						if (((getNeighbours(imageTest, i, j)[0] == false) ||(getNeighbours(imageTest, i, j)[2] == false) || (getNeighbours(imageTest, i, j)[6] == false)) &&
								((getNeighbours(imageTest, i, j)[0] == false) ||(getNeighbours(imageTest, i, j)[4] == false) || (getNeighbours(imageTest, i, j)[6] == false))) {
							imageTest4[i][j] = false;
							System.out.println("deleted !");
						}


					}

					System.out.println();
				}
			}
		}
		return imageTest4;
	}

	/**

	 * Compute the skeleton of a boolean image.

	 * @param image array containing each pixel's boolean value.
	 * @return array containing the boolean value of each pixel of the image after
	 *         applying the thinning algorithm.

	 */

	public static boolean[][] thin(boolean[][] image) {

		assert (image != null);

		// création tableau test 1 pour ne pas modifier le tableau initial
		// création tableau test 2 qui va être modifié (step 1)
		// création tableau test 3 qui va être modifié (step 2)

		boolean[][] imageTest1 = new boolean[image.length][image[0].length];

		for (int i = 0; i < image.length; ++i) {
			for (int j = 0; j < image[i].length; ++j) {
				imageTest1[i][j] = image[i][j];
			}
		}

		boolean change;

		do {
			boolean[][] imageTest2 = thinningStep(imageTest1, 0);
			boolean[][] imageTest3 = thinningStep(imageTest2, 1);

			if (!identical(imageTest1, imageTest3)) {
				for (int i = 0; i < imageTest1.length; ++i) {
					for (int j = 0; j < imageTest1[i].length; ++j) {
						imageTest1[i][j] = imageTest3[i][j];
					}
				}
			}
			//

			change = !identical(imageTest2, imageTest3);


		} while (change);

		return imageTest1;

	}


	/**
	 * Compute the skeleton of a boolean image.
	 *
	 * @param image array containing each pixel's boolean value.
	 * @return array containing the boolean value of each pixel of the image after
	 *         applying the thinning algorithm.
	 */
 /* public static boolean[][] thin(boolean[][] image) {
	  //TODO implement
	  return null;
  }

  /**
   * Computes all pixels that are connected to the pixel at coordinate
   * <code>(row, col)</code> and within the given distance of the pixel.
   *
   * @param image    array containing each pixel's boolean value.
   * @param row      the first coordinate of the pixel of interest.
   * @param col      the second coordinate of the pixel of interest.
   * @param distance the maximum distance at which a pixel is considered.
   * @return An array where <code>true</code> means that the pixel is within
   *         <code>distance</code> and connected to the pixel at
   *         <code>(row, col)</code>.
   */
	public static boolean[][] connectedPixels(boolean[][] image, int row, int col, int distance) {
		//TODO implement
		return null;
	}

	/**
	 * Computes the slope of a minutia using linear regression.
	 *
	 * @param connectedPixels the result of
	 *                        {@link #connectedPixels(boolean[][], int, int, int)}.
	 * @param row             the row of the minutia.
	 * @param col             the col of the minutia.
	 * @return the slope.
	 */
	public static double computeSlope(boolean[][] connectedPixels, int rowM, int colM) {

		assert (connectedPixels != null);

		// initialisation des variables

		double slope = 0.;

		double somme_x2 = 0;
		double somme_y2 = 0;
		double somme_xy = 0;



		for (int row = 0; row < connectedPixels.length; ++row) {
			for (int col = 0; col < connectedPixels[row].length; ++col) {

				// x et y exprimés en fonction de l'origine du repère, centré sur la minutie
				int x = col - colM;
				int y = rowM - row;

				if (connectedPixels[row][col]) {
					somme_x2 += x * x;
					somme_y2 += y * y;
					somme_xy += x * y;
				}
			}
		}

		if (somme_x2 == 0) {
			slope = Double.POSITIVE_INFINITY;
			return slope;
		}

		else {

			if (somme_x2 >= somme_y2) {
				slope = somme_xy / somme_x2;
			} else {
				slope = somme_y2 / somme_xy;
			}

			return slope;
		}
	}


	/**
	 * Computes the orientation of a minutia in radians.
	 *
	 * @param connectedPixels the result of
	 *                        {@link #connectedPixels(boolean[][], int, int, int)}.
	 * @param row             the row of the minutia.
	 * @param col             the col of the minutia.
	 * @param slope           the slope as returned by
	 *                        {@link #computeSlope(boolean[][], int, int)}.
	 * @return the orientation of the minutia in radians.
	 */
	public static double computeAngle(boolean[][] connectedPixels, int rowM, int colM, double slope) {

		// calcul de l'angle formé par le vecteur direction
		double angle = Math.atan(slope);


		// variable qui compte le nombre de pixels au dessus et en dessous
		int pixelUp = 0;
		int pixelDown = 0;

		// boucle qui verifie que les conditions soient respectées

		for (int row = 0; row < connectedPixels.length; ++row) {
			for (int col = 0; col < connectedPixels[row].length; ++col) {

				// x et y exprimés en fonction de l'origine du repère, centré sur la minutie
				int x = col - colM;
				int y = rowM - row;

				boolean pixelNoir = connectedPixels[row][col];

				if (pixelNoir && (y >= ((-1/slope) * x))) {
					pixelUp += 1;
				} else if (pixelNoir && (y < ((-1/slope) * x))) {
					pixelDown += 1;
				}
			}
		}

		// conditions qui déterminent l'ajout potentiel de PI à l'angle calculé au début
		if ((slope == Double.POSITIVE_INFINITY && (pixelUp > pixelDown))) {
			// on est d'accord, le "au dessus de la minutie" c'est bien de la perpendiculaire ???
			angle  = Math.PI / 2;
		}

		else if ((slope == Double.POSITIVE_INFINITY && (pixelUp < pixelDown))) {
			angle  =  - Math.PI / 2;
		}

		else if ((angle > 0 && (pixelDown > pixelUp)) || (angle < 0 && (pixelDown < pixelUp))) {
			// vérifier si c'est strictement sup / inf ou pas !!!!! si non = what if == ????
			angle += Math.PI;
		}

		return angle;
	}

	/**
	 * Computes the orientation of the minutia that the coordinate <code>(row,
	 * col)</code>.
	 *
	 * @param image    array containing each pixel's boolean value.
	 * @param row      the first coordinate of the pixel of interest.
	 * @param col      the second coordinate of the pixel of interest.
	 * @param distance the distance to be considered in each direction to compute
	 *                 the orientation.
	 * @return The orientation in degrees.
	 */
	public static int computeOrientation(boolean[][] image, int row, int col, int distance) {
		//
		// angle en radian
		//double angleR = computeAngle(computeSlope(connectedPixels(image, row, col, distance)));
		//angleR = Math.toDegrees(angleR);

		// angle en dégré (rounded)
		//int angleD = Math.round(angleD);
		// initialisé à double mais comment le rendre int ?

		// if (angleD < 0) {
		//	  angleD += 360;
		//}

		//return angleD;
		// comment savoir les coordonnées de la minutie ??

		//
		return 0;
	}
